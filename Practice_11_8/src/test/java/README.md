# LeetCode 题目 栈
  题目来源：https://leetcode.cn/studyplan/top-interview-150/  （面试经典150题-栈部分）
  题目：1.简化路径 2.最小栈 3.逆波兰表达式


## 1.简化路径
### 题目描述
给你一个字符串 path，表示指向某一文件或目录的 Unix 风格绝对路径（以 "/" 开头），请你将其转化为更加简洁的规范路径。

在 Unix 风格的文件系统中，规则如下：
一个点 . 表示当前目录本身。
两个点 .. 表示将目录切换到上一级（指向父目录）。
任意多个连续的斜杠（即，// 或 ///）都被视为单个斜杠 /。
任何其他格式的点（例如，... 或 ....）均被视为有效的文件/目录名称。

返回的简化路径必须遵循下述格式：
始终以斜杠 / 开头。
两个目录名之间必须只有一个斜杠 /。
最后一个目录名（如果存在）不能以 / 结尾。
此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 . 或 ..）。

### 解题思路
分割路径：将路径按 / 分割成多个部分。
处理每个部分：
如果是 ..，则返回上一级目录（如果栈不为空）。
如果是 . 或空字符串，则忽略。
其他情况，将其视为目录名，压入栈中。
构建结果：将栈中的目录名用 / 连接起来，形成最终的规范路径。

### 复杂度分析
时间复杂度：O(n)，其中 n 是路径的长度。每个部分只会被处理一次。
空间复杂度：O(n)，栈的大小最多为 n。

## 最小栈（min stack）
### 题目描述

设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。
实现 MinStack 类：
MinStack() 初始化堆栈对象。
void push(int val) 将元素 val 推入堆栈。
void pop() 删除堆栈顶部的元素。
int top() 获取堆栈顶部的元素。
int getMin() 获取堆栈中的最小元素

### 解题思路

方法：使用辅助栈
主栈：用于存储所有元素。
辅助栈：用于存储当前栈中的最小值。每当主栈压入一个新元素时，辅助栈也压入当前的最小值。这样，辅助栈的栈顶始终是主栈中的最小值。

#### 关键类分析：
MinStack 类：
使用两个 Deque：stack 和 minStack。

stack 用于存储所有元素。
minStack 用于存储当前栈中的最小值。

push 方法：
将元素压入 stack。
如果 minStack 为空，或者新元素小于等于 minStack 的栈顶元素，则将新元素压入 minStack。

pop 方法：
弹出 stack 的栈顶元素。

如果弹出的元素等于 minStack 的栈顶元素，则也弹出 minStack 的栈顶元素。

### 复杂度分析

时间复杂度：  push、pop 和 getMin 操作的时间复杂度均为 O(1)。

空间复杂度： 使用了两个栈，最坏情况下 O(n) 空间存储最小值。


## 逆波兰表达式

### 题目描述
根据逆波兰表示法（Reverse Polish Notation, RPN），求表达式的值。
有效的运算符包括 +, -, *, /。每个操作数可以是整数或其他逆波兰表达式。
逆波兰表达式的特点：
操作数在前，操作符在后。
操作符作用于最近的两个操作数。
操作数之间用空格分隔。

### 解题思路

1. 遍历表达式：
如果当前元素是操作数（数字），则将其压入栈中。
如果当前元素是操作符（+, -, *, /），则从栈中弹出两个操作数，进行相应的运算，并将结果压入栈中。
2. 最终结果：
遍历结束后，栈中剩下的唯一元素就是表达式的值。

### 复杂度分析

时间复杂度：O(n), n 是表达式的长度。

空间复杂度：O(n)，栈的大小最多为 n。


## LRU算法复习
（略）