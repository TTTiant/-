# 项目名称
动态规划算法题、LRU缓存机制
题目来源：牛客网-模版速刷TOP101


## 题目&解题思路

语言：Java

### 1.BM69 把数字翻译成字符串
有一种将字母编码成数字的方式：'a'->1, 'b->2', ... , 'z->26'。
现在给一串数字，返回有多少种可能的译码结果。

### 解题思路
动态规划核心思路是：将一个大问题分解为相互关联的子问题，通过子问题一步步的去解决原大问题。

所以根据这题的题目，可以看出：
1.当只存在一个字符时，只要字符不为0（0<char<10),译码结果就有一种, 例如：'a' --- '1'；
2.当存在两个字符时，把两个字符看成一个整体，就需要先判断是否0 < str < 26，在这个范围内才可以去译码。
通过上述总结的规则和动态规划的累加逻辑可以的出状态转移方程：

判断一个字符时： if oneDigit <= 9 && oneDigit >0；dp[i] += dp[i-1];

判断第二个字符时： if twoDigit <= 26 && twoDigit >=10； dp[i] += dp[i-2];

同时：dp[0] = 1;
     dp[1] = 1;

思考：dp[i] += dp[i-1]也可以写成 dp[i] = dp[i-1]，因为初始的dp[i] = 0, 但是增加代码的可读性和
展示出它的累加逻辑，这样更好。

### 2.BM70 兑换零钱
给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，
每种面值的货币可以使用任意张， 再给定一个aim，代表要找的钱数，求组成aim的最少货币数。
如果无解，请返回-1。

### 解题思路
同样运用动态规划的思路。

首先假设要求兑换i值的张数，我手里现在有面值为arr[j]的零钱，那么i值所要兑换所需的张数等于（i-arr[j]）这个面值
所需要的张数加一，然后通过循环不同的零钱面值，比较出最小张数。
状态转移方程就是：dp[i] = min(dp[i], dp[i-coin]+1)

同时我们要找出边界条件:

1.aim小于面值最小的零钱那就无法兑换返回-1。
2.并且任何零钱组合都不能等于aim返回-1。
3.通过题意，得出dp[0] = 0。

### 3.LRU缓存机制
请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
实现 LRUCache 类：
LRUCache(int capacity) 以 正整数 作为容量 capacity 初始化 LRU 缓存
int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。
void put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该 逐出 最久未使用的关键字。
函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。
### 解题思路









